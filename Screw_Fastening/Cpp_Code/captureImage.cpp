///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 18.05
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(__arm__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;


#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image, ho_ModelRegion, ho_TemplateImage;
  HObject  ho_ModelContours, ho_TransContours;

  // Local control variables
  HTuple  hv_ModelID, hv_ModelRegionArea, hv_RefRow;
  HTuple  hv_RefColumn, hv_HomMat2D, hv_Row, hv_Column, hv_Angle;
  HTuple  hv_Scale, hv_Score, hv_I, hv_AcqHandle;

  //
  //Matching 01: ************************************************
  //Matching 01: BEGIN of generated code for model initialization
  //Matching 01: ************************************************
  SetSystem("border_shape_models", "false");
  //
  //Matching 01: Obtain the model image
  ReadImage(&ho_Image, "/home/cct/temp/win.bmp");
  //
  //Matching 01: Build the ROI from basic regions
  GenRectangle2(&ho_ModelRegion, 495.06, 1285.84, HTuple(-89.9844).TupleRad(), 133.277, 
      203.652);
  //
  //Matching 01: Reduce the model template
  ReduceDomain(ho_Image, ho_ModelRegion, &ho_TemplateImage);
  //
  //Matching 01: Create the shape model
  CreateScaledShapeModel(ho_TemplateImage, 6, HTuple(0).TupleRad(), HTuple(360).TupleRad(), 
      HTuple(0.5069).TupleRad(), 0.96, 1.04, 0.0044, (HTuple("point_reduction_high").Append("no_pregeneration")), 
      "use_polarity", ((HTuple(11).Append(82)).Append(55)), 4, &hv_ModelID);
  //
  //Matching 01: Get the model contour for transforming it later into the image
  GetShapeModelContours(&ho_ModelContours, hv_ModelID, 1);
  //
  //Matching 01: Get the reference position
  AreaCenter(ho_ModelRegion, &hv_ModelRegionArea, &hv_RefRow, &hv_RefColumn);
  VectorAngleToRigid(0, 0, 0, hv_RefRow, hv_RefColumn, 0, &hv_HomMat2D);
  AffineTransContourXld(ho_ModelContours, &ho_TransContours, hv_HomMat2D);
  //
  //Matching 01: Display the model contours
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"green");
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"margin");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_ModelRegion, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_TransContours, HDevWindowStack::GetActive());
  // stop(...); only in hdevelop
  //
  //Matching 01: END of generated code for model initialization
  //Matching 01:  * * * * * * * * * * * * * * * * * * * * * * *
  //Matching 01: BEGIN of generated code for model application
  //Matching 01: The following operations are usually moved into
  //Matching 01: that loop where the acquired images are processed
  //
  //Matching 01: Find the model
  FindScaledShapeModel(ho_Image, hv_ModelID, HTuple(0).TupleRad(), HTuple(360).TupleRad(), 
      0.96, 1.04, 0.6, 0, 0.5, "least_squares", (HTuple(6).Append(1)), 0.75, &hv_Row, 
      &hv_Column, &hv_Angle, &hv_Scale, &hv_Score);
  //
  //Matching 01: Transform the model contours into the detected positions
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  {
  HTuple end_val45 = (hv_Score.TupleLength())-1;
  HTuple step_val45 = 1;
  for (hv_I=0; hv_I.Continue(end_val45, step_val45); hv_I += step_val45)
  {
    HomMat2dIdentity(&hv_HomMat2D);
    HomMat2dScale(hv_HomMat2D, HTuple(hv_Scale[hv_I]), HTuple(hv_Scale[hv_I]), 0, 
        0, &hv_HomMat2D);
    HomMat2dRotate(hv_HomMat2D, HTuple(hv_Angle[hv_I]), 0, 0, &hv_HomMat2D);
    HomMat2dTranslate(hv_HomMat2D, HTuple(hv_Row[hv_I]), HTuple(hv_Column[hv_I]), 
        &hv_HomMat2D);
    AffineTransContourXld(ho_ModelContours, &ho_TransContours, hv_HomMat2D);
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),"green");
    if (HDevWindowStack::IsOpen())
      DispObj(ho_TransContours, HDevWindowStack::GetActive());
    // stop(...); only in hdevelop
  }
  }
  //
  //Matching 01: *******************************************
  //Matching 01: END of generated code for model application
  //Matching 01: *******************************************
  //
  //Image Acquisition 01: Code generated by Image Acquisition 01
  OpenFramegrabber("GigEVision2", 0, 0, 0, 0, 0, 0, "progressive", -1, "default", 
      -1, "false", "default", "0007482f371b_TheImagingSourceEuropeGmbH_DFK33GP1300", 
      0, -1, &hv_AcqHandle);
  GrabImage(&ho_Image, hv_AcqHandle);
  //Image Acquisition 01: Do something

  WriteImage(ho_Image, "jpeg", 0, "/home/cct/temp/aaa");
  CloseFramegrabber(hv_AcqHandle);

}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  // Wait until the timer has fired to start processing.
  LockMutex(gStartMutex);
  UnlockMutex(gStartMutex);

  try
  {
    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
  }

  // Tell the main thread to terminate itself.
  LockMutex(gStartMutex);
  gTerminate = TRUE;
  UnlockMutex(gStartMutex);
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    HBOOL terminate;

    CFRunLoopRun();

    LockMutex(gStartMutex);
    terminate = gTerminate;
    UnlockMutex(gStartMutex);

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#elif defined(__linux__) && !defined(__arm__)
    XInitThreads();
#endif

    // Default settings used in HDevelop (can be omitted) 
    SetSystem("width", 512);
    SetSystem("height", 512);

#ifndef __APPLE__
    action();
#else
    ret = apple_main(argc,argv);
#endif
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    ret = 1;
  }
  return ret;
}

#endif


#endif


