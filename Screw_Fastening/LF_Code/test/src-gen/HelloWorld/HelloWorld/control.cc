/*
 * This file was autogenerated by the Lingua Franca Compiler.
 *
 * Source: platform:/resource/test/src/HelloWorld.lf
 */

#include "HelloWorld/control.hh"

using namespace reactor::operators;

  // private preamble

// outer constructor
control::control(const std::string& name, reactor::Environment* __lf_environment, Parameters&& __lf_parameters)
  : reactor::Reactor(name, __lf_environment)
  , __lf_inner(this, std::forward<Parameters>(__lf_parameters))
  //reactor instances
  // timers
  // actions
  , up{"up", this, reactor::Duration::zero()}
  , origin{"origin", this, reactor::Duration::zero()}
  , ready{"ready", this, reactor::Duration::zero()}
            
  // reaction views
  
  
  
  
{
            
            
  // reaction views
  
  
  
  
}
control::control(const std::string& name, reactor::Reactor* __lf_container, Parameters&& __lf_parameters)
  : reactor::Reactor(name, __lf_container)
  , __lf_inner(this, std::forward<Parameters>(__lf_parameters))
  //reactor instances
  // timers
  // actions
  , up{"up", this, reactor::Duration::zero()}
  , origin{"origin", this, reactor::Duration::zero()}
  , ready{"ready", this, reactor::Duration::zero()}
            
  // reaction views
  
  
  
  
{
            
            
  // reaction views
  
  
  
  
}

// inner constructor
control::Inner::Inner(::reactor::Reactor* reactor, Parameters&& __lf_parameters)
  : LFScope(reactor)
  , Parameters(std::forward<Parameters>(__lf_parameters))
  // state variables
  , integral_x(0)
  , integral_y(0)
  , period_1(1000ms)
  , period_2(2000ms)
  , b_reset(false)
  , already_reset(false)
{}

void control::assemble() {
  // r0
  r0.declare_trigger(&error_x);
  r0.declare_trigger(&error_y);
  r0.declare_trigger(&z);
  r0.declare_trigger(&detectionNumber);
          
  r0.declare_antidependency(&speed_x);
  r0.declare_antidependency(&speed_y);
  r0.declare_antidependency(&speed_z);
          
  
  // r1
  r1.declare_trigger(&z);
  r1.declare_trigger(&detectionNumber);
          
  r1.declare_antidependency(&speed_z);
  r1.declare_schedulable_action(&up);
  r1.declare_schedulable_action(&origin);
          
  
  // r2
  r2.declare_trigger(&up);
          
  r2.declare_antidependency(&speed_z);
  r2.declare_schedulable_action(&origin);
          
  
  // r3
  r3.declare_trigger(&origin);
          
  r3.declare_antidependency(&position_x);
  r3.declare_antidependency(&position_y);
  r3.declare_antidependency(&position_z);
  // connections
}

// methods


// reaction pid control

void control::Inner::r0_body(
  [[maybe_unused]] const reactor::Input<double>& error_x,
  [[maybe_unused]] const reactor::Input<double>& error_y,
  [[maybe_unused]] const reactor::Input<double>& z,
  [[maybe_unused]] const reactor::Input<int>& detectionNumber,
  reactor::Output<float>& speed_x,
  reactor::Output<float>& speed_y,
  reactor::Output<float>& speed_z)  {
  if(b_reset)
      return;
  if(*detectionNumber.get() == 0 || *z.get() < 0.360){ //*0.339
      std::cout << "pid control will be disabled" << endl;
      //speed_z.set(0.0);
      return;
  }
  //integral_x = 0;
  //integral_y = 0;
  
  double t_speed_x = Kp * (*error_x.get()) + Ki * integral_x;
  double t_speed_y = Kp * (*error_y.get()) + Ki * integral_y;
  cout << "---------------------Speed----------------------"<<endl;
  cout << "speed_x = "<<Kp << " * "<<*error_x.get()<<" + "<<Ki<<" * "<<integral_x<<endl;
  cout << "speed_y = "<<Kp << " * "<<*error_y.get()<<" + "<<Ki<<" * "<<integral_y<<endl;
  cout << "---------------------Error----------------------"<<endl;
  cout<<"Error_x: "<<*error_x.get()<<" Error_y: "<<*error_y.get()<<endl;
  cout<<"t_speed_x: "<<t_speed_x<<" t_speed_y: "<<t_speed_y<<endl;
  //PID control x
  if (fabs(t_speed_x) <= speed_x_Threshold){
    cout << "Pixel ErrorX" <<endl;
    if(fabs(integral_x) <= IntegralX_Threshold){
      integral_x += (*error_x.get()) ;
    }  
  }
  else if(t_speed_x > speed_x_Threshold){
    t_speed_x = speed_x_Threshold;
  }
  else if(t_speed_x < speed_x_Threshold){
    t_speed_x = -speed_x_Threshold;
  }
  
  //PID control y
  if (fabs(t_speed_y) <= speed_y_Threshold){
    cout << "Pixel ErrorY" <<endl;
    if(fabs(integral_y) <= IntegralY_Threshold){
      integral_y += (*error_y.get()) ;
    }  
  }
  else if(t_speed_y > speed_y_Threshold){
    t_speed_y = speed_y_Threshold;
  }
  else if(t_speed_y < speed_y_Threshold){
    t_speed_y = -speed_y_Threshold;
  }
  
  double t_speed_z = -0.005;
  if(abs(*error_x.get()) > 300){
      t_speed_z = 0.02;
      if((*z.get()) > 0.450){
           t_speed_z = -0.005;
      }
  }
  
  speed_x.set(t_speed_x);
  speed_y.set(t_speed_y);
  speed_z.set(t_speed_z);
  cout << "speed x: "<<t_speed_x <<"speed y:"<< t_speed_y <<"speed z:"<<t_speed_z<<endl;
}

// reaction reset control

void control::Inner::r1_body(
  [[maybe_unused]] const reactor::Input<double>& z,
  [[maybe_unused]] const reactor::Input<int>& detectionNumber,
  reactor::Output<float>& speed_z,
  reactor::LogicalAction<void>& up,
  reactor::LogicalAction<void>& origin)  {
  std::cout << "z.is_present()" << z.is_present() <<"b_reset"<<b_reset<<"*detectionNumber.get()"<<*detectionNumber.get()<<"*z.get()"<<*z.get()<< endl;
  if(detectionNumber.is_present() && *detectionNumber.get()>0){
      already_reset = false;
  }
  if(!z.is_present())
      return;
  if(*z.get() > 0.405)
      b_reset = false;
  if(b_reset)
      return;
  
  
  if( *detectionNumber.get() == 0 && !already_reset){//0.339
      std::cout << "*detectionNumber.get() = "<<*detectionNumber.get() << std::endl;
      b_reset = true;
      integral_x = 0.0;
      integral_y = 0.0;
      speed_z.set(0.0);
      already_reset = true;
      origin.schedule(period_2);
  }else if(*z.get() < 0.360){
      std::cout << "reset control" << std::endl;
      b_reset = true;
      integral_x = 0.0;
      integral_y = 0.0;
      speed_z.set(0.0);
      up.schedule(period_2);
  }
}

// reaction screwer up

void control::Inner::r2_body(
  [[maybe_unused]] const reactor::LogicalAction<void>& up,
  reactor::Output<float>& speed_z,
  reactor::LogicalAction<void>& origin)  {
  std::cout << "screwer up control" << std::endl;
  speed_z.set(0.02);
  origin.schedule(period_2);
}

// reaction go to origin position

void control::Inner::r3_body(
  [[maybe_unused]] const reactor::LogicalAction<void>& origin,
  reactor::Output<double>& position_x,
  reactor::Output<double>& position_y,
  reactor::Output<double>& position_z)  {
  std::cout << "go to origin position control" << std::endl;
  position_x.set(0.0);
  position_y.set(0.0);
  position_z.set(0.0);
}

        
