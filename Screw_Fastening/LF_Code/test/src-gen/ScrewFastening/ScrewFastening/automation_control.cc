/*
 * This file was autogenerated by the Lingua Franca Compiler.
 *
 * Source: platform:/resource/test/src/ScrewFastening.lf
 */

#include "ScrewFastening/automation_control.hh"

using namespace reactor::operators;

  // private preamble

// outer constructor
automation_control::automation_control(const std::string& name, reactor::Environment* __lf_environment, Parameters&& __lf_parameters)
  : reactor::Reactor(name, __lf_environment)
  , __lf_inner(this, std::forward<Parameters>(__lf_parameters))
  //reactor instances
  // timers
  // actions
  , up{"up", this, reactor::Duration::zero()}
  , origin{"origin", this, reactor::Duration::zero()}
  , ready{"ready", this, reactor::Duration::zero()}
            
  // reaction views
  
  
  
  
  
{
            
            
  // reaction views
  
  
  
  
  
}
automation_control::automation_control(const std::string& name, reactor::Reactor* __lf_container, Parameters&& __lf_parameters)
  : reactor::Reactor(name, __lf_container)
  , __lf_inner(this, std::forward<Parameters>(__lf_parameters))
  //reactor instances
  // timers
  // actions
  , up{"up", this, reactor::Duration::zero()}
  , origin{"origin", this, reactor::Duration::zero()}
  , ready{"ready", this, reactor::Duration::zero()}
            
  // reaction views
  
  
  
  
  
{
            
            
  // reaction views
  
  
  
  
  
}

// inner constructor
automation_control::Inner::Inner(::reactor::Reactor* reactor, Parameters&& __lf_parameters)
  : LFScope(reactor)
  , Parameters(std::forward<Parameters>(__lf_parameters))
  // state variables
  , Kp(0.00005)
  , Ki(0.0000008)
  , integral_x(0)
  , integral_y(0)
  , sleep(2000ms)
  , b_reset(false)
  , already_reset(false)
{}

void automation_control::assemble() {
  // r0
  r0.declare_trigger(&error_x);
  r0.declare_trigger(&error_y);
  r0.declare_trigger(&z);
          
  r0.declare_antidependency(&speed_x);
  r0.declare_antidependency(&speed_y);
  r0.declare_antidependency(&speed_z);
          
  
  // r1
  r1.declare_trigger(&detection_num);
          
  r1.declare_antidependency(&speed_z);
  r1.declare_schedulable_action(&origin);
          
  
  // r2
  r2.declare_trigger(&z);
          
  r2.declare_antidependency(&speed_z);
  r2.declare_schedulable_action(&up);
          
  
  // r3
  r3.declare_trigger(&up);
          
  r3.declare_antidependency(&speed_z);
  r3.declare_schedulable_action(&origin);
          
  
  // r4
  r4.declare_trigger(&origin);
          
  r4.declare_antidependency(&position_x);
  r4.declare_antidependency(&position_y);
  r4.declare_antidependency(&position_z);
  // connections
}

// methods


// reaction pid control

void automation_control::Inner::r0_body(
  [[maybe_unused]] const reactor::Input<double>& error_x,
  [[maybe_unused]] const reactor::Input<double>& error_y,
  [[maybe_unused]] const reactor::Input<double>& z,
  reactor::Output<float>& speed_x,
  reactor::Output<float>& speed_y,
  reactor::Output<float>& speed_z)  {
  //sometimes error_x is present,but not valid,
  //TODO:
  std::cout  << "pid control: Logical time is " << get_logical_time() << " Microstep: " << get_microstep() <<std::endl;
  if(!error_x.is_present() || !error_y.is_present()){
      return;
  }
  if(b_reset )
      return;
  
  if( *z.get() < 0.360){ //*0.339
      std::cout << "pid control will be disabled" << endl;
      return;
  }
  
  double t_speed_x = Kp * (*error_x.get()) + Ki * integral_x;
  double t_speed_y = Kp * (*error_y.get()) + Ki * integral_y;
  cout << "---------------------Speed----------------------"<<endl;
  cout << "speed_x = "<<Kp << " * "<<*error_x.get()<<" + "<<Ki<<" * "<<integral_x<<endl;
  cout << "speed_y = "<<Kp << " * "<<*error_y.get()<<" + "<<Ki<<" * "<<integral_y<<endl;
  
  
  //PID control x
  if (fabs(t_speed_x) <= speed_x_Threshold){
    if(fabs(integral_x) <= IntegralX_Threshold){
      integral_x += (*error_x.get()) ;
    }  
  }
  else if(t_speed_x > speed_x_Threshold){
    t_speed_x = speed_x_Threshold;
  }
  else if(t_speed_x < speed_x_Threshold){
    t_speed_x = -speed_x_Threshold;
  }
  
  //PID control y
  if (fabs(t_speed_y) <= speed_y_Threshold){
    if(fabs(integral_y) <= IntegralY_Threshold){
      integral_y += (*error_y.get()) ;
    }  
  }
  else if(t_speed_y > speed_y_Threshold){
    t_speed_y = speed_y_Threshold;
  }
  else if(t_speed_y < speed_y_Threshold){
    t_speed_y = -speed_y_Threshold;
  }
  
  double t_speed_z = -0.004;
  if(abs(*error_x.get()) > 300){
      t_speed_z = 0.02;
      if((*z.get()) > 0.450){
           t_speed_z = -0.004;
      }
  }
  
  speed_x.set(t_speed_x);
  speed_y.set(t_speed_y);
  speed_z.set(t_speed_z);
  cout << "speed x: "<<t_speed_x <<"speed y:"<< t_speed_y <<"speed z:"<<t_speed_z<<endl;
}

// reaction reset control

void automation_control::Inner::r1_body(
  [[maybe_unused]] const reactor::Input<int>& detection_num,
  reactor::Output<float>& speed_z,
  reactor::LogicalAction<void>& origin)  {
  std::cout <<"b_reset"<<b_reset<<"*detection_num.get()"<<*detection_num.get()<< endl;
  if(*detection_num.get() > 0){
      already_reset = false;
  }
  
  if(b_reset)
      return;
  
  if( *detection_num.get() == 0 && !already_reset){
      std::cout << "*detection_num.get() = "<<*detection_num.get() << std::endl;
      b_reset = true;
      integral_x = 0.0;
      integral_y = 0.0;
      speed_z.set(0.0);
      already_reset = true;
      origin.schedule(sleep);
  }
}

// reaction start screwing

void automation_control::Inner::r2_body(
  [[maybe_unused]] const reactor::Input<double>& z,
  reactor::Output<float>& speed_z,
  reactor::LogicalAction<void>& up)  {
  std::cout << "z.is_present()" << z.is_present() <<"b_reset"<<b_reset<<"*z.get()"<<*z.get()<< endl;
  
  if(!z.is_present())
      return;
  if(*z.get() > 0.405)
      b_reset = false;
  
  if(b_reset)
      return;
  
  if(*z.get() < 0.339){
      std::cout << "reset control" << std::endl;
      b_reset = true;
      integral_x = 0.0;
      integral_y = 0.0;
      speed_z.set(0.0);
      up.schedule(sleep);
  }
}

// reaction screwer up

void automation_control::Inner::r3_body(
  [[maybe_unused]] const reactor::LogicalAction<void>& up,
  reactor::Output<float>& speed_z,
  reactor::LogicalAction<void>& origin)  {
  std::cout << "screwer up control" << std::endl;
  speed_z.set(0.02);
  origin.schedule(sleep);
}

// reaction go to origin position

void automation_control::Inner::r4_body(
  [[maybe_unused]] const reactor::LogicalAction<void>& origin,
  reactor::Output<double>& position_x,
  reactor::Output<double>& position_y,
  reactor::Output<double>& position_z)  {
  std::cout << "go to origin position control" << std::endl;
  position_x.set(0.0);
  position_y.set(0.0);
  position_z.set(0.0);
}

        
